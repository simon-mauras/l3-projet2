* Pouvoir ajouter facilement des clauses à notre formule
* Trouver pourquoi un literal a été assigné à une valeur donnée:
    Supposition: None
    Propagation: Some <indice de la clause unitaire que l'on a utilisé>
* Se souvenir de quand le literal a été assigné dans le niveau de déduction courant.


Algorithme:
On vient de détecter une clause C_1 non satisfaite car on vient d'assigne le literal X à une valeur donnée.
On regarde pourquoi le litéral a été assigné à la valeur donnée:
-> Supposition:
    on remonte
-> Propagation:
    On se donne la clause C_2 qui a entrainé l'assignation de X à la valeur donnée.
    On fait la résolution sur C_1 et C_2. On a encore une clause fausse. On regarde le dernier literal assigné, on regarde pourquoi il a été assigné à sa valeur, […]
    On effectue cette résolution jusqu'à arriver à un littéral assigné par supposition. Parrallèlement, on maintient un graphe des implications: A -> B si la valeur de B a été déduite de A.

    On recherche ensuite un UIP dans ce graphe. Pour celà, on peut partir du conflit du début et générer tout les chemins dans notre graphe qui y mènent partant de la supposition.
    (en pratique on parcours notre graphe en restant au niveau de déduction courant).
    de départ. On fait ensuite l'intersection des ensembles de noeuds de tout les chemins: les noeuds présents dans cette intersection sont des UIP.
    On choisit ensuite le niveau d'UIP que l'on souhaite utiliser (en pratique on prendra notre premier uip)
    Notre clause fautive est composée de l'ensemble des noeuds qui ne sont pas du niveau de décision courant et qui antécédents des noeuds du niveau de décision courant qui sont fils, petit-fils, ... de notre UIP,
    ainsi que de notre UIP.
